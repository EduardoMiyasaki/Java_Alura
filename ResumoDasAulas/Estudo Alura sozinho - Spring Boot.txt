Estudo Alura sozinho - Spring Boot

A interface CommandLineRunner representa uma tarefa a ser executada após a inicialização do Spring Boot, ou seja, permite definir código para ser executado automaticamente quando o aplicativo é iniciado.

A interface CommandLineRunner é bem versátil e pode ser usada em diversas situações. Conforme mencionado anteriormente, ela pode ser usada para carregar dados para um banco de dados. Também pode ser usada para iniciar recursos, como conexões de rede, e para checar a integridade de determinados componentes ou serviços com os quais a aplicação irá interagir.

É importante lembrar que a CommandLineRunner é executada apenas na inicialização da aplicação, então não deve ser utilizada para tarefas que precisam ocorrer periodicamente durante o funcionamento da aplicação, para isso, Spring oferece outras ferramentas que serão mais adequadas.

Vamos imaginar uma situação onde temos que carregar uma grande quantidade de dados em nosso banco de dados assim que nossa aplicação Spring iniciar. Bem, manualmente isso seria desafiador e demorado, no entanto, a interface CommandLineRunner torna essa tarefa extremamente mais simples.

Utilizando @JsonProperty quando você desserializa um json ele ira passar o valor da chave valor para o campo
correto
porem quando ele serializar um json ele ira passar com o nome anterior
ex:
@JsonProperty("imdbVotes") String votos
quando for desseariliza ele vai passar os dados para votos
mas quando for serializar vai criar um campo chamado imdbVotes ao invés de votos

o @JsonAlias não faz isso, vai criar o campo de acordo com o atributo no caso seria votos, ele só le do json

dentro dessa anotação podemos colocar um Array então se for procurar em outra API podemos capturar os nome sem problemas
@JsonAlias({"Title","Titulo"}) String titulo

Quando o JSON é serializado, isto é, convertido de objetos Java para JSON, o nome especificado em @JsonProperty será usado como a chave para o campo no JSON de saída
 Da mesma forma, quando o JSON é desserializado (convertido de JSON para objetos Java), a biblioteca procura pelo nome especificado em @JsonProperty para mapear o valor JSON para o campo Java.

public interface IConverteDados {

    <T> T obterDados(String json, Class<T> classe);
}

criamos um método em uma interface, que irá retornar alguma coisa, porém não sabemos ainda
e também criamos no paramêtro a classe que nós queremos converter porém não sabemos de que tipo ela é ainda

public class ConverterDados implements IConverteDados {

    private ObjectMapper mapper = new ObjectMapper();

    @Override
    public <T> T obterDados(String json, Class<T> classe) {
        try {
            return mapper.readValue(json, classe);
        } catch (JsonProcessingException e) {
            throw new ValidacaoException(e.getMessage());
        }
    }

@JsonIgnoreProperties(ignoreUnknown = true) para o Jackson ignorar todos os campos que ele não encontrar similiaridade entre o json e a classe

Em Java, generics permitem criar classes, interfaces e métodos que podem trabalhar com tipos desconhecidos ou parâmetros genéricos.Eles fornecem uma forma de escrever código flexível e reutilizável, tornando-o independente de tipos específicos e permitindo que ele funcione com diferentes tipos de dados.

A verificação é realizada usando os operadores instanceof e os operadores de pattern matching (instanceof com pattern variables) disponíveis a partir do Java 16
if (this.conteudo instanceof Integer c && valor instanceof Integer i) {
    Integer resultado = c + i;
    return (T) resultado;
}

o Spring por padrão quando chama o starter ele ja chama a biblioteca Jackson

List: Uma coleção ordenada que permite elementos duplicados. Os elementos são acessados por índices.

Set: Uma coleção que não permite elementos duplicados e normalmente não possui ordem definida.

Queue: Uma coleção que representa uma fila, onde os elementos são adicionados no final e removidos do início.

Map: Uma coleção de pares chave-valor, onde cada chave é única e mapeada para um valor correspondente.

final= não pode ser alterado futuramente(Tem que ser tudo maisculo o nome da variável e separando as palavras por underscore (_),)
private final String ENDERECO = "https://www.omdbapi.com/?t=";

Além disso, é uma boa prática declarar as constantes como static caso elas pertençam a uma classe e sejam compartilhadas por vários objetos. Dessa forma, as constantes podem ser acessadas diretamente através do nome da classe, sem a necessidade de instanciar um objeto.

System.out.println(“Eu trabalho na empresa “ +  ExemploConstantes.NOME_EMPRESA);


